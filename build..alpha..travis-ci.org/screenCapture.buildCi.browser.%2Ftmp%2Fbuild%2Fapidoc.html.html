<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://mths.be/he">he (v1.1.1)</a>
</h1>
<h4>A robust HTML entities encoder/decoder with full Unicode support.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.he">module he</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.he.decode">
            function <span class="apidocSignatureSpan">he.</span>decode
            <span class="apidocSignatureSpan">(html, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.he.encode">
            function <span class="apidocSignatureSpan">he.</span>encode
            <span class="apidocSignatureSpan">(string, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.he.escape">
            function <span class="apidocSignatureSpan">he.</span>escape
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.he.unescape">
            function <span class="apidocSignatureSpan">he.</span>unescape
            <span class="apidocSignatureSpan">(html, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">he.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.he" id="apidoc.module.he">module he</a></h1>


    <h2>
        <a href="#apidoc.element.he.decode" id="apidoc.element.he.decode">
        function <span class="apidocSignatureSpan">he.</span>decode
        <span class="apidocSignatureSpan">(html, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (html, options) {
		options = merge(options, decode.options);
		var strict = options.strict;
		if (strict &amp;&amp; regexInvalidEntity.test(html)) {
			parseError('malformed character reference');
		}
		return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7) {
			var codePoint;
			var semicolon;
			var decDigits;
			var hexDigits;
			var reference;
			var next;
			if ($1) {
				// Decode decimal escapes, e.g. `&amp;#119558;`.
				decDigits = $1;
				semicolon = $2;
				if (strict &amp;&amp; !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(decDigits, 10);
				return codePointToSymbol(codePoint, strict);
			}
			if ($3) {
				// Decode hexadecimal escapes, e.g. `&amp;#x1D306;`.
				hexDigits = $3;
				semicolon = $4;
				if (strict &amp;&amp; !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(hexDigits, 16);
				return codePointToSymbol(codePoint, strict);
			}
			if ($5) {
				// Decode named character references with trailing `;`, e.g. `&amp;copy;`.
				reference = $5;
				if (has(decodeMap, reference)) {
					return decodeMap[reference];
				} else {
					// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands
					if (strict) {
						parseError(
							'named character reference was not terminated by a semicolon'
						);
					}
					return $0;
				}
			}
			// If weâ€™re still here, itâ€™s a legacy reference for sure. No need for an
			// extra `if` check.
			// Decode named character references without trailing `;`, e.g. `&amp;amp`
			// This is only a parse error if it gets converted to `&amp;`, or if it is
			// followed by `=` in an attribute context.
			reference = $6;
			next = $7;
			if (next &amp;&amp; options.isAttributeValue) {
				if (strict &amp;&amp; next == '=') {
					parseError('`&amp;` did not start a character reference');
				}
				return $0;
			} else {
				if (strict) {
					parseError(
						'named character reference was not terminated by a semicolon'
					);
				}
				// Note: there is no need to check `has(decodeMapLegacy, reference)`.
				return decodeMapLegacy[reference] + (next || '');
			}
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
he.encode.options.useNamedReferences = true;

// Using the global default setting, which is now `true`:
he.encode('foo Â© bar â‰&nbsp; baz ðŒ† qux');
// â†’ 'foo &amp;copy; bar &amp;ne; baz &amp;#x1D306; qux'
```

### `he.<span class="apidocCodeKeywordSpan">decode</span>(html, options)`

This function takes a string of HTML and decodes any named and numerical character references in it using [the algorithm described
 in section 12.2.4.69 of the HTML spec](https://html.spec.whatwg.org/multipage/syntax.html#tokenizing-character-references).

```js
he.decode('foo &amp;copy; bar &amp;ne; baz &amp;#x1D306; qux');
// â†’ 'foo Â© bar â‰&nbsp; baz ðŒ† qux'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.he.encode" id="apidoc.element.he.encode">
        function <span class="apidocSignatureSpan">he.</span>encode
        <span class="apidocSignatureSpan">(string, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (string, options) {
		options = merge(options, encode.options);
		var strict = options.strict;
		if (strict &amp;&amp; regexInvalidRawCodePoint.test(string)) {
			parseError('forbidden code point');
		}
		var encodeEverything = options.encodeEverything;
		var useNamedReferences = options.useNamedReferences;
		var allowUnsafeSymbols = options.allowUnsafeSymbols;
		var escapeCodePoint = options.decimal ? decEscape : hexEscape;

		var escapeBmpSymbol = function(symbol) {
			return escapeCodePoint(symbol.charCodeAt(0));
		};

		if (encodeEverything) {
			// Encode ASCII symbols.
			string = string.replace(regexAsciiWhitelist, function(symbol) {
				// Use named references if requested &amp; possible.
				if (useNamedReferences &amp;&amp; has(encodeMap, symbol)) {
					return '&amp;' + encodeMap[symbol] + ';';
				}
				return escapeBmpSymbol(symbol);
			});
			// Shorten a few escapes that represent two symbols, of which at least one
			// is within the ASCII range.
			if (useNamedReferences) {
				string = string
					.replace(/&amp;gt;\u20D2/g, '&amp;nvgt;')
					.replace(/&amp;lt;\u20D2/g, '&amp;nvlt;')
					.replace(/&amp;#x66;&amp;#x6A;/g, '&amp;fjlig;');
			}
			// Encode non-ASCII symbols.
			if (useNamedReferences) {
				// Encode non-ASCII symbols that can be replaced with a named reference.
				string = string.replace(regexEncodeNonAscii, function(string) {
					// Note: there is no need to check `has(encodeMap, string)` here.
					return '&amp;' + encodeMap[string] + ';';
				});
			}
			// Note: any remaining non-ASCII symbols are handled outside of the `if`.
		} else if (useNamedReferences) {
			// Apply named character references.
			// Encode `&lt;&gt;"'&amp;` using named character references.
			if (!allowUnsafeSymbols) {
				string = string.replace(regexEscape, function(string) {
					return '&amp;' + encodeMap[string] + ';'; // no need to check `has()` here
				});
			}
			// Shorten escapes that represent two symbols, of which at least one is
			// `&lt;&gt;"'&amp;`.
			string = string
				.replace(/&amp;gt;\u20D2/g, '&amp;nvgt;')
				.replace(/&amp;lt;\u20D2/g, '&amp;nvlt;');
			// Encode non-ASCII symbols that can be replaced with a named reference.
			string = string.replace(regexEncodeNonAscii, function(string) {
				// Note: there is no need to check `has(encodeMap, string)` here.
				return '&amp;' + encodeMap[string] + ';';
			});
		} else if (!allowUnsafeSymbols) {
			// Encode `&lt;&gt;"'&amp;` using hexadecimal escapes, now that theyâ€™re not handled
			// using named character references.
			string = string.replace(regexEscape, escapeBmpSymbol);
		}
		return string
			// Encode astral symbols.
			.replace(regexAstralSymbols, function($0) {
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				var high = $0.charCodeAt(0);
				var low = $0.charCodeAt(1);
				var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
				return escapeCodePoint(codePoint);
			})
			// Encode any remaining BMP symbols that are not printable ASCII symbols
			// using a hexadecimal escape.
			.replace(regexBmpWhitelist, escapeBmpSymbol);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## API

### `he.version`

A string representing the semantic version number.

### `he.<span class="apidocCodeKeywordSpan">encode</span>(text, options)`

This function takes a string of text and encodes (by default) any symbols that arenâ€™t printable ASCII symbols and `&amp;`, `&lt;
;`, `&gt;`, `"`, `'`, and `` ` ``, replacing them with character references.

```js
he.encode('foo Â© bar â‰&nbsp; baz ðŒ† qux');
// â†’ 'foo &amp;#xA9; bar &amp;#x2260; baz &amp;#x1D306; qux'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.he.escape" id="apidoc.element.he.escape">
        function <span class="apidocSignatureSpan">he.</span>escape
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function (string) {
		return string.replace(regexEscape, function($0) {
			// Note: there is no need to check `has(escapeMap, $0)` here.
			return escapeMap[$0];
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
he.decode.options.isAttributeValue = true;

// Using the global default setting, which is now `true`:
he.decode('foo&amp;ampbar');
// â†’ 'foo&amp;ampbar'
```

### `he.<span class="apidocCodeKeywordSpan">escape</span>(text)`

This function takes a string of text and escapes it for use in text contexts in XML or HTML documents. Only the following characters
 are escaped: `&amp;`, `&lt;`, `&gt;`, `"`, `'`, and `` ` ``.

```js
he.escape('&lt;img src=\'x\' onerror="prompt(1)"&gt;');
// â†’ '&amp;lt;img src=&amp;#x27;x&amp;#x27; onerror=&amp;quot;prompt(1)&amp;quot;&amp;gt;'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.he.unescape" id="apidoc.element.he.unescape">
        function <span class="apidocSignatureSpan">he.</span>unescape
        <span class="apidocSignatureSpan">(html, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unescape = function (html, options) {
		options = merge(options, decode.options);
		var strict = options.strict;
		if (strict &amp;&amp; regexInvalidEntity.test(html)) {
			parseError('malformed character reference');
		}
		return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7) {
			var codePoint;
			var semicolon;
			var decDigits;
			var hexDigits;
			var reference;
			var next;
			if ($1) {
				// Decode decimal escapes, e.g. `&amp;#119558;`.
				decDigits = $1;
				semicolon = $2;
				if (strict &amp;&amp; !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(decDigits, 10);
				return codePointToSymbol(codePoint, strict);
			}
			if ($3) {
				// Decode hexadecimal escapes, e.g. `&amp;#x1D306;`.
				hexDigits = $3;
				semicolon = $4;
				if (strict &amp;&amp; !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(hexDigits, 16);
				return codePointToSymbol(codePoint, strict);
			}
			if ($5) {
				// Decode named character references with trailing `;`, e.g. `&amp;copy;`.
				reference = $5;
				if (has(decodeMap, reference)) {
					return decodeMap[reference];
				} else {
					// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands
					if (strict) {
						parseError(
							'named character reference was not terminated by a semicolon'
						);
					}
					return $0;
				}
			}
			// If weâ€™re still here, itâ€™s a legacy reference for sure. No need for an
			// extra `if` check.
			// Decode named character references without trailing `;`, e.g. `&amp;amp`
			// This is only a parse error if it gets converted to `&amp;`, or if it is
			// followed by `=` in an attribute context.
			reference = $6;
			next = $7;
			if (next &amp;&amp; options.isAttributeValue) {
				if (strict &amp;&amp; next == '=') {
					parseError('`&amp;` did not start a character reference');
				}
				return $0;
			} else {
				if (strict) {
					parseError(
						'named character reference was not terminated by a semicolon'
					);
				}
				// Note: there is no need to check `has(decodeMapLegacy, reference)`.
				return decodeMapLegacy[reference] + (next || '');
			}
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This function takes a string of text and escapes it for use in text contexts in XML or HTML documents. Only the following characters
 are escaped: `&amp;`, `&lt;`, `&gt;`, `"`, `'`, and `` ` ``.

```js
he.escape('&lt;img src=\'x\' onerror="prompt(1)"&gt;');
// â†’ '&amp;lt;img src=&amp;#x27;x&amp;#x27; onerror=&amp;quot;prompt(1)&amp;quot;&amp;gt;'
```

### `he.<span class="apidocCodeKeywordSpan">unescape</span>(html, options)`

`he.unescape` is an alias for `he.decode`. It takes a string of HTML and decodes any named and numerical character references in
 it.

### Using the `he` binary

To use the `he` binary in your shell, simply install _he_ globally using npm:
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>